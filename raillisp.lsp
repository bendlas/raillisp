
(set start-time (utime))
(set start-here (here))

(var raillisp-version "0.1")

(defcode if (test true &rest false)
  (compile-r test)
  (if,)
  (compile true)
  (else,)
  (compile-progn false)
  (then,))

(defcode while (test &rest body)
  (begin,)
  (compile-r test)
  (while,)
  (compile-list-nr body)
  (repeat,)
  (maybe-ret))

(defcode dotimes (spec &rest body)
  (let* ((v (car (cdr spec))))
    (if (int? v)
        (untag-lit, v)
      (compile-r v)
      (untag-num,)))
  (untag-lit, 0)
  (do,)
  (set loop-vars (cons (car spec) loop-vars))
  (compile-list-nr body)
  (set loop-vars (cdr loop-vars))
  (loop,)
  (maybe-ret))

(defmacro dolist (spec &rest body)
  (list 'let* (list (list '--tail-- (car (cdr spec)))
                    (list (car spec) 'nil))
        (list 'while '--tail--
              (list 'set (car spec) '(car --tail--))
              '(set --tail-- (cdr --tail--))
              (cons 'progn body))))

(defcode cond (&rest forms)
  (dolist (x forms)
    (compile-r (car x))
    (if,)
    (compile-progn (cdr x))
    (else,))
  (dolist (x forms)
    (then,)))

(defcode and (&rest conditions)
  (dolist (x conditions)
    (compile-r x)
    (if,))
  (return-lit t)
  (dolist (x conditions)
    (else,)
    (return-lit nil)
    (then,)))

(defcode or (&rest conditions)
  (dolist (x conditions)
    (compile-r x)
    (if,)
    (return-lit t)
    (else,))
  (return-lit nil)
  (dolist (x conditions)
    (then,)))

(defun println (obj)
  (print obj)
  (cr))

(defun repl ()
  (cr)
  (while 1
    (println (eval (read-from-input)))))

(defun mapcar (fn lst)
  (if lst
      (cons (funcall fn (list (car lst))) (mapcar fn (cdr lst)))
    lst))

(defcode when (test &rest body)
  (compile-r test)
  (if,)
  (compile-progn body)
  (then,))

(defun caar (x) (car (car x)))
(defun cadr (x) (car (cdr x)))
(defun cdar (x) (cdr (car x)))
(defun cddr (x) (cdr (cdr x)))

(defun nthcdr (n list)
  (dotimes (_ n)
    (set list (cdr list)))
  list)

(defun nth (n list)
  (car (nthcdr n list)))

(defun last (list)
  (if list
      (nthcdr (1- (list-len list)) list)
    nil))

(defun str-append (a b)
  (var s (make-empty-str (+ (str-len a) (str-len b))))
  (str-move! s a 0)
  (str-move! s b (str-len a)))

(defun str->list (s)
  (var end (1- (str-len s)))
  (var l nil)
  (dotimes (i (1+ end))
    (set l (cons (str-ref s (- end i)) l)))
  l)

(defun list->str (char-list)
  (var len (list-len char-list))
  (var s (make-str len 0))
  (dotimes (i len)
    (str-set s i (car char-list))
    (set char-list (cdr char-list)))
  s)

(defun str-join (strings sep)
  (var strings-len 0)
  (var ret nil)
  (var sep-len (str-len sep))
  (let* ((len 0))
    (dolist (s strings)
      (set len (+ len (+ (str-len s) sep-len)))
      (set strings-len (1+ strings-len)))
    (set len (- len sep-len))
    (set ret (make-empty-str len)))
  (let* ((offset 0))
    (dotimes (i (1- strings-len))
      (let* ((s (car strings)))
        (set strings (cdr strings))
        (str-move! ret s offset)
        (set offset (+ offset (str-len s))))
      (str-move! ret sep offset)
      (set offset (+ offset sep-len)))
    (str-move! ret (car strings) offset))
  ret)

(defun init ()
  (if (not (boundp '_noinit_))
      (progn
        (process-args)
        (if (= (list-len command-line-args) 0)
            (progn
              (print "// Raillisp ")
              (print raillisp-version)
              (println " \\\\")
              (repl))
          (load (car command-line-args))
          (bye))
        nil)))

(var lisp-init-time (- (utime) start-time))
(var lisp-dict-space (- (here) start-here))

(init)
